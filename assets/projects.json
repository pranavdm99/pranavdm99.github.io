{
    "energy-rl": {
        "title": "Energy-Aware Language-Conditioned Manipulation",
        "tag": "Reinforcement Learning",
        "heroImage": "assets/project-rl.png",
        "mission": "Controllable energy-success tradeoffs in robotic manipulation via natural language conditioning.",
        "problem": "Standard RL optimizes for 'what' to do, not 'how'. Agents often 'reward hack'—e.g., slamming a door to open it—resulting in high torque spikes, wasted energy, and potential hardware damage with no intuitive way to modulate behavior post-training.",
        "solution": "Built a language-conditioned policy in Robosuite (Franka Panda) that maps natural language commands ('carefully', 'quickly', 'normally') to physical energy budgets. Leveraging the ECO (Energy-Constrained Optimization) framework with Lagrangian multipliers and Sentence-BERT embeddings, the system treats energy as a hard constraint. This enables instant behavior switching (92% success @ 32% energy savings) without retraining.",
        "stack": [
            "Python",
            "PyTorch",
            "MuJoCo (Robosuite)",
            "Sentence-BERT",
            "Soft Actor-Critic (SAC)"
        ],
        "metrics": [
            {
                "label": "Energy Savings ('Efficiently')",
                "value": "32%"
            },
            {
                "label": "Jerk Reduction (Smoothness)",
                "value": "80%+"
            },
            {
                "label": "Success Rate ('Normally')",
                "value": "100%"
            }
        ],
        "pivots": [
            {
                "title": "Closing the Reward Hack",
                "description": "Initial agents shoved doors open using the wrist. I pivoted to a physics-grounded reward that mandates gripper-to-handle contact, ensuring the robot actually grasps and pulls—shifting from outcome-based to behavior-based success."
            },
            {
                "title": "Zero-Shot Language Control",
                "description": "By conditioning the Lagrangian budget on SBERT embeddings, the policy learned to map semantic intent to physical constraints. This allows a user to trade off reliability for efficiency in real-time just by changing the command string."
            }
        ],
        "plots": [
            {
                "url": "assets/energy_rl_tradeoff.png",
                "caption": "Success-energy tradeoff: Pareto frontier across diverse language-conditioned budgets."
            },
            {
                "url": "assets/energy_rl_torque.png",
                "caption": "Torque impact: 80% smoother motion via energy-aware optimization."
            }
        ]
    },
    "cfd-uav": {
        "title": "Physics-Informed Robust Drone Navigation",
        "tag": "Robotics & Path Planning",
        "heroImage": "assets/project-uav.png",
        "mission": "Automated vision-to-simulation pipeline for resilient global planning in geometry-dense turbulent environments.",
        "problem": "UAVs in cluttered urban-like zones face unpredictable localized turbulence. Standard A* planners ignore aerodynamic costs, resulting in high trajectory deviation and energy loss. Rapidly prototyping these environments manually is also slow and unscalable.",
        "solution": "Developed a 'Digital Twin' pipeline: an overhead ZED camera extracts obstacle geometries, start/goal points, and fan-based wind inlets via AprilTags. A FluidX3D CFD solver generates a 2D wind costmap of the static environment. A hybrid A* and Bezier-curve planner then identifies preferential paths—leveraging shielded zones or tailwinds—to minimize aerodynamic impact, executed on a Crazyflie 2.1 using a Lee controller.",
        "stack": [
            "Python",
            "ROS 2",
            "FluidX3D",
            "Crazyflie 2.1",
            "ZED Camera (OpenCV)",
            "AprilTags"
        ],
        "metrics": [
            {
                "label": "95th Dev Reduction (Crosswind)",
                "value": "49.5%"
            },
            {
                "label": "Frechet Dev Reduction (Mixed)",
                "value": "36.9%"
            },
            {
                "label": "Max Dev Reduction (Headwind)",
                "value": "13.0%"
            }
        ],
        "pivots": [
            {
                "title": "Configurable Physics Costmap",
                "description": "Shifted from treating obstacles as binary collisions to treating them as aerodynamic shields. This allowed the planner to choose slightly longer paths that stay in 'shadow' zones, significantly improving tracking stability."
            },
            {
                "title": "Automated Env Mapping",
                "description": "Implemented an AprilTag-based vision system to instantly map physical lab setups to the CFD grid, reducing environmental configuration time from hours to seconds and enabling rapid testing across 3+ complex wind scenarios."
            }
        ],
        "plots": [
            {
                "url": "assets/wind_field2.jpeg",
                "caption": "Physics-Informed Path: The CFD planner (green) avoids high-wind zones, preferring the shielded lee-sides of obstacles compared to the baseline A* (red)."
            }
        ]
    },
    "sram-cim": {
        "title": "SRAM-Based Compute-In-Memory Accelerator",
        "tag": "Embedded Machine Learning",
        "heroImage": "assets/65x10-8b-6tsram-instance.png",
        "mission": "Overcoming the von Neumann 'memory wall' via in-memory analog parallel MAC operations.",
        "problem": "Traditional architectures face a bottleneck: moving data between memory and processor consumes 100x more energy than the computation itself. Real-time inference on edge devices requires a paradigm shift to compute where the data lives.",
        "solution": "Designed and simulated a 65x10 SRAM-based CIM array using Cadence Virtuoso. By integrating neural network weights directly into memory cells and developing custom word-line drivers and sense amplifiers, the system performs parallel multiply-accumulate operations in the analog domain for high-speed, low-power MNIST classification.",
        "stack": [
            "Cadence Virtuoso",
            "Spectre Simulation",
            "SRAM Design",
            "Analog/Mixed-Signal",
            "MNIST (PyTorch Model Extraction)"
        ],
        "metrics": [
            {
                "label": "Energy Efficiency",
                "value": "1.13 nJ/inf"
            },
            {
                "label": "Inference Latency",
                "value": "1.30 \u00b5s"
            },
            {
                "label": "EDP (Energy-Delay Product)",
                "value": "1.47 fJ\u00b7s"
            },
            {
                "label": "Classification Accuracy",
                "value": "90.9%"
            }
        ],
        "pivots": [
            {
                "title": "Peripheral Scalability",
                "description": "Pivoted from manual bit-line control to automated word-line drivers with precise timing constraints, ensuring the analog sensing window was wide enough to handle non-ideal cell discharge across the 65x10 array."
            },
            {
                "title": "Non-Linearity Mitigation",
                "description": "Developed a custom sense amplifier layout to compensate for local process variations, maintaining the linearity of the analog accumulation for the final layer of the MNIST classifier."
            }
        ],
        "plots": [
            {
                "url": "assets/65x10-8b-6tsram-instance.png",
                "caption": "SRAM-CIM Physical Design: Silicon layout of the 8-bit word-line instance architecture."
            },
            {
                "url": "assets/sram-circuit-analysis.png",
                "caption": "Analog MAC Analysis: Signal propagation and analog domain multiply-accumulate verification."
            },
            {
                "url": "assets/sram-sim-results.png",
                "caption": "Inference Benchmarks: Spectre simulation results across MNIST test vectors."
            }
        ]
    },
    "multi-agent-rl": {
        "title": "MAS Drone Coordination (MAPPO vs IPPO)",
        "tag": "Multi-Agent RL",
        "heroImage": "assets/hero-bg.png",
        "mission": "Cooperative formation flying using coordinated multi-agent reinforcement learning.",
        "problem": "Independent agents (IPPO) diverge in 'coupled' tasks (e.g., spirals) because the environment becomes non-stationary as other agents learn. Absolute coordinates also introduce 'Origin Bias' that breaks generalization.",
        "solution": "Implemented a Custom MAPPO framework with CTDE (Centralized Training, Decentralized Execution) and Relative Coordinate Encoding. Optimized O(N) scaling for the centralized critic to manage Joint-State (N x 12) inputs without performance lag.",
        "stack": [
            "Python",
            "PyTorch",
            "Pybullet",
            "MARL-CTDE"
        ],
        "metrics": [
            {
                "label": "Collision Rate",
                "value": "2.1%"
            },
            {
                "label": "Spiral RMSE",
                "value": "0.25m"
            },
            {
                "label": "Sample Efficiency",
                "value": "1.42x"
            }
        ],
        "pivots": [
            {
                "title": "Origin-Agnostic Learning",
                "description": "Switched from absolute to relative coordinate frames. This pivot eliminated the 'Origin Bias', allowing drones to coordinate based on proximity rather than their starting positions."
            }
        ],
        "plots": [
            {
                "url": "assets/marl_simulation.png",
                "caption": "Spiral Formation Tracking: Comparing Custom MAPPO against Stable-Baselines3 (SB3)."
            }
        ]
    },
    "kalman-tracking": {
        "title": "Robust Kalman Filter for Object Tracking",
        "tag": "Perception & State Estimation",
        "heroImage": "assets/project-gait.png",
        "mission": "Precise pose estimation of moving targets under high sensor noise and visual outliers.",
        "problem": "AprilTag tracking in dynamic scenes often suffers from 'jumpy' results due to partial occlusions. Standard Kalman Filters are sensitive to these outliers, causing erratic and unreliable state estimates.",
        "solution": "Implemented a Robust Kalman Filter using incremental Expectation-Maximization (EM) to learn outlier distributions online. The system dynamically weights measurements, 'distrusting' noisy spikes while maintaining sub-5ms inference on Raspberry Pi.",
        "stack": [
            "C++",
            "ROS 2",
            "MATLAB",
            "Raspberry Pi"
        ],
        "metrics": [
            {
                "label": "NRMSE Reduction",
                "value": "79.8%"
            },
            {
                "label": "Baseline NRMSE",
                "value": "0.094"
            },
            {
                "label": "Robust NRMSE",
                "value": "0.019"
            }
        ],
        "pivots": [
            {
                "title": "EM Online Learning",
                "description": "Initially used static noise models which failed in variable lighting. Implemented online parameter learning to adapt to changing track quality in real-time."
            }
        ],
        "plots": [
            {
                "url": "assets/kalman_tracking.png",
                "caption": "Robust Kalman Filter: Estimated x y z plotted against time and raw data"
            }
        ]
    },
    "telemetry-bms": {
        "title": "Distributed Telemetry System",
        "tag": "Embedded Systems",
        "heroImage": "assets/project-bms.png",
        "mission": "Monitor and control large-scale electric vehicle fleets with 24/7 reliability across diverse client requirements.",
        "problem": "Collecting cell-level battery data across cellular networks requires massive bandwidth, and serving diverse clients (fleet operators, BMS vendors, EV OEMs) means the firmware must simultaneously support keyless vehicle security, real-time driving analytics, OBD data extraction, and OTA management — all on a single constrained MCU with deterministic timing guarantees.",
        "solution": "Developed bare-metal C/C++ firmware on Renesas RA2L1 (ARM Cortex-M23), implementing low-level system drivers for UART, SPI, I2C, and CAN with optimal memory layout. Integrated IMU and GNSS sensors validated through field testing on live vehicles. Delivered a 2.6x lossless edge-compression algorithm and edge computing for battery health monitoring and charging/discharging control. OTA firmware and BMS configuration updates over CAN (ISO-TP), co-existing with real-time driving alert generation (harsh acceleration, harsh braking, over-speeding) and Bluetooth-based mobilization/immobilization commands.",
        "stack": [
            "C / C++ (Bare-metal)",
            "Renesas RA2L1 (Cortex-M23)",
            "CAN J1939 / ISO-TP",
            "RS-485 (MODBUS)",
            "MQTT",
            "Protobuf / Base64",
            "AIS-140",
            "IMU / GNSS"
        ],
        "metrics": [
            {
                "label": "Reliability Rate",
                "value": "97%+"
            },
            {
                "label": "Data Compression",
                "value": "2.6x"
            },
            {
                "label": "Protocols Implemented",
                "value": "8+"
            }
        ],
        "pivots": [
            {
                "title": "Fault-Tolerant OTA",
                "description": "Implemented persistent flash buffers and a safety-first rollback mechanism to ensure zero bricking even during cellular signal drops — critical for remote fleet management at 5000+ unit scale."
            },
            {
                "title": "Protocol Versatility",
                "description": "A single TCU firmware had to speak multiple industrial dialects: CAN J1939 OBD collection, ISO-TP framed BMS updates, RS-485 (MODBUS) for energy meter data, AIS-140 government compliance, and Protobuf + Base64 encoding for bandwidth-efficient MQTT telemetry. Each integration required careful buffer management to avoid priority inversion on the shared UART/CAN peripherals."
            }
        ],
        "plots": []
    }
}